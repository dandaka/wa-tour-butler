import { Boom } from '@hapi/boom';
import makeWASocket, {
  useMultiFileAuthState,
  DisconnectReason,
  proto,
  MessageUpsertType,
  MediaType,
  getHistoryMsg,
  downloadAndProcessHistorySyncNotification,
  BaileysEventMap
} from 'baileys';
import path from 'path';
import fs from 'fs';
import Database from 'better-sqlite3';
type DB = ReturnType<typeof Database>;

// Target group name and expected JID (from group_messages.json)
const TARGET_GROUP_NAME = "Dom19h Saldanha P4ALL M4+";

// Number of messages to fetch and store
const MESSAGE_LIMIT = 100;

// Store path for session data
const SESSION_DIR = path.join(process.cwd(), 'session');

// SQLite database path
const DB_PATH = path.join(process.cwd(), 'group_messages.db');

// Initialize SQLite database
function initializeDatabase() {
  const db = new Database(DB_PATH);
  
  // Create messages table if it doesn't exist
  db.exec(`
    CREATE TABLE IF NOT EXISTS messages (
      id TEXT PRIMARY KEY,
      remoteJid TEXT NOT NULL,
      fromMe BOOLEAN NOT NULL,
      participant TEXT,
      pushName TEXT,
      timestamp INTEGER NOT NULL,
      content TEXT,
      messageType TEXT,
      quotedMessageId TEXT,
      raw TEXT
    )
  `);
  
  // Create participants table if it doesn't exist
  db.exec(`
    CREATE TABLE IF NOT EXISTS participants (
      jid TEXT PRIMARY KEY,
      name TEXT,
      lastSeen INTEGER
    )
  `);
  
  // Create groups table if it doesn't exist
  db.exec(`
    CREATE TABLE IF NOT EXISTS groups (
      jid TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      description TEXT,
      participantCount INTEGER,
      lastUpdated INTEGER
    )
  `);
  
  console.log(`Database initialized at ${DB_PATH}`);
  return db;
}

/**
 * Format a phone number or ID to a clean format
 */
function formatPhoneNumber(phoneNumber: string): string {
  return phoneNumber.replace(/[^0-9]/g, '');
}

/**
 * Get the message content as text
 */
function extractMessageContent(message: proto.IMessage | null | undefined): string {
  if (!message) return '';
  
  if (message.conversation) {
    return message.conversation;
  } else if (message.extendedTextMessage?.text) {
    return message.extendedTextMessage.text;
  } else if (message.imageMessage?.caption) {
    return message.imageMessage.caption;
  } else if (message.videoMessage?.caption) {
    return message.videoMessage.caption;
  } else if (message.documentMessage?.fileName) {
    return `[Document: ${message.documentMessage.fileName}]`;
  } else if (message.audioMessage) {
    return '[Audio]';
  } else if (message.stickerMessage) {
    return '[Sticker]';
  } else if (message.contactMessage) {
    return '[Contact]';
  } else if (message.locationMessage) {
    return '[Location]';
  } else {
    return JSON.stringify(message);
  }
}

/**
 * Determine the message type
 */
function getMessageType(message: proto.IMessage | null | undefined): string {
  if (!message) return 'unknown';
  
  if (message.conversation) {
    return 'text';
  } else if (message.extendedTextMessage) {
    return 'text';
  } else if (message.imageMessage) {
    return 'image';
  } else if (message.videoMessage) {
    return 'video';
  } else if (message.audioMessage) {
    return 'audio';
  } else if (message.documentMessage) {
    return 'document';
  } else if (message.stickerMessage) {
    return 'sticker';
  } else if (message.contactMessage) {
    return 'contact';
  } else if (message.locationMessage) {
    return 'location';
  } else {
    return 'other';
  }
}

/**
 * Get quoted message ID if present
 */
function getQuotedMessageId(message: proto.IMessage | null | undefined): string | null {
  if (!message?.extendedTextMessage?.contextInfo?.quotedMessage) {
    return null;
  }
  
  return message.extendedTextMessage.contextInfo.stanzaId || null;
}

/**
 * Store a message in the database
 */
function storeMessage(db: DB, msg: proto.IWebMessageInfo): void {
  try {
    // Extract and ensure all values are SQLite-compatible types
    const messageId = (msg.key?.id || '').toString();
    const remoteJid = (msg.key?.remoteJid || '').toString();
    const fromMe = msg.key?.fromMe ? 1 : 0;
    const participant = msg.key?.participant ? msg.key.participant.toString() : null;
    const pushName = msg.pushName ? msg.pushName.toString() : null;
    
    // Ensure timestamp is a number
    let timestamp = 0;
    if (typeof msg.messageTimestamp === 'number') {
      timestamp = msg.messageTimestamp;
    } else if (msg.messageTimestamp) {
      timestamp = parseInt(msg.messageTimestamp.toString(), 10) || 0;
    }
    
    // Get message content safely
    const content = extractMessageContent(msg.message);
    const messageType = getMessageType(msg.message);
    const quotedMessageId = getQuotedMessageId(msg.message);
    
    // Convert the whole message to JSON for backup
    // Handle circular references in message object
    const raw = JSON.stringify(msg, (key, value) => {
      // Handle BigInt values which can't be serialized to JSON
      if (typeof value === 'bigint') {
        return value.toString();
      }
      return value;
    });
    
    console.log(`Storing message: ${messageId} (${messageType}) from ${participant || 'me'}`);

    
    // Prepare statement for insertion or update
    const insertStmt = db.prepare(`
      INSERT OR REPLACE INTO messages
      (id, remoteJid, fromMe, participant, pushName, timestamp, content, messageType, quotedMessageId, raw)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    // Execute the statement
    insertStmt.run(
      messageId,
      remoteJid,
      fromMe,
      participant,
      pushName,
      timestamp,
      content,
      messageType,
      quotedMessageId,
      raw
    );
    
    // Also update participant info if available
    if (participant && pushName) {
      const participantStmt = db.prepare(`
        INSERT OR REPLACE INTO participants
        (jid, name, lastSeen)
        VALUES (?, ?, ?)
      `);
      
      participantStmt.run(
        participant,
        pushName,
        Math.floor(Date.now() / 1000)
      );
    }
  } catch (error) {
    console.error('Error storing message:', error);
    throw error;
  }
}

/**
 * Store group information in the database
 */
function storeGroupInfo(db: DB, jid: string, name: string, description: string | null, participantCount: number): void {
  try {
    const stmt = db.prepare(`
      INSERT OR REPLACE INTO groups
      (jid, name, description, participantCount, lastUpdated)
      VALUES (?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      jid,
      name,
      description,
      participantCount,
      Math.floor(Date.now() / 1000)
    );
    
    console.log(`Stored group info for ${name} (${jid})`);
  } catch (error) {
    console.error('Error storing group info:', error);
  }
}

/**
 * Get the most recent message timestamp in the database for a group
 */
function getLastMessageTimestamp(db: DB, jid: string): number {
  try {
    const stmt = db.prepare(`
      SELECT MAX(timestamp) as lastTimestamp FROM messages
      WHERE remoteJid = ?
    `);
    
    const result = stmt.get(jid) as { lastTimestamp: number | null };
    return result.lastTimestamp || 0;
  } catch (error) {
    console.error('Error getting last message timestamp:', error);
    return 0;
  }
}

/**
 * Check if session credentials exist
 */
function checkSessionExists(): boolean {
  try {
    return fs.existsSync(path.join(SESSION_DIR, 'creds.json'));
  } catch (error) {
    console.error('Error checking session existence:', error);
    return false;
  }
}

/**
 * Parse time period argument (1h, 1d, 1w) into milliseconds
 */
function parseTimePeriod(arg: string | undefined): number {
  if (!arg) {
    // Default to 1 day if no argument is provided
    return 24 * 60 * 60 * 1000;
  }
  
  const match = arg.match(/^(\d+)([hdw])$/);
  if (!match) {
    console.warn(`Invalid time period format: ${arg}, using 1 day as default`);
    return 24 * 60 * 60 * 1000;
  }
  
  const value = parseInt(match[1], 10);
  const unit = match[2];
  
  switch (unit) {
    case 'h': return value * 60 * 60 * 1000; // hours
    case 'd': return value * 24 * 60 * 60 * 1000; // days
    case 'w': return value * 7 * 24 * 60 * 60 * 1000; // weeks
    default: return 24 * 60 * 60 * 1000; // fallback to 1 day
  }
}

/**
 * Track pending message history requests
 */
const onDemandRequestMap = new Map<string, string>();

// Define interfaces for the event data
interface Chat {
  id: string;
  name: string;
  messages?: proto.IWebMessageInfo[];
}

/**
 * Main function for syncing group messages with the database
 */
async function syncGroupMessages() {
  // Get time period from command line arguments
  const timePeriodArg = process.argv.find(arg => /^\d+[hdw]$/.test(arg));
  const timePeriod = parseTimePeriod(timePeriodArg);
  const timePeriodDesc = timePeriodArg || '1d';
  
  console.log(`Starting WhatsApp sync for group "${TARGET_GROUP_NAME}" (messages from last ${timePeriodDesc})...`);
  
  console.log('\n====== IMPORTANT INSTRUCTIONS ======');
  console.log('1. KEEP YOUR WHATSAPP MOBILE APP OPEN during the entire sync process');
  console.log('2. For best results, open the target group chat on your phone');
  console.log('3. The sync process may take up to 2 minutes');
  console.log('4. This script will NOT send any messages to your group');
  console.log('================================\n');
  
  // Check if we have session credentials
  if (!checkSessionExists()) {
    console.log('\n\x1b[31m==================================\x1b[0m');
    console.log('\x1b[31mERROR: WhatsApp session not found\x1b[0m');
    console.log('\x1b[31mPlease run the login script first:\x1b[0m');
    console.log('\x1b[36mpnpm run whatsapp-login\x1b[0m');
    console.log('\x1b[31m==================================\x1b[0m\n');
    process.exit(1);
  }
  
  console.log('Loading WhatsApp session...');
  
  // Initialize SQLite database
  const db = initializeDatabase();
  
  // Connect to WhatsApp
  const { state, saveCreds } = await useMultiFileAuthState(SESSION_DIR);
  const sock = makeWASocket({
    auth: state,
    printQRInTerminal: true,
  });
  
  // Save credentials on update
  sock.ev.on('creds.update', saveCreds);
  
  let targetGroupJid: string | null = null;
  let messagesAdded = 0;
  
  // Process new messages as they come in
  sock.ev.on('connection.update', (update) => {
    const { connection, lastDisconnect } = update;
    console.log('Connection update:', update);

    if (connection === 'close') {
      // Check if the connection was closed due to an error or logout
      const shouldReconnect =
        (lastDisconnect?.error as Boom)?.output?.statusCode !== DisconnectReason.loggedOut;
      
      if (shouldReconnect) {
        console.log('Connection closed due to error, reconnecting...');
        startSock();
      } else {
        console.log('Connection closed. You have been logged out.');
        process.exit(0); // Exit the process cleanly
      }
    } else if (connection === 'open') {
      console.log('Connected to WhatsApp!');
    }
  });
  
  // Listen for history sync events which should trigger when we request message history
  sock.ev.on('messaging-history.set', (data) => {
    const { chats, contacts, messages, isLatest, syncType } = data;
    console.log(`Received messaging history: ${messages.length} messages, type: ${syncType}`);
    
    if (messages && messages.length > 0) {
      console.log('Successfully received message history!');
      // Process the received messages
      let newMessages = 0;
      for (const msg of messages) {
        try {
          if (msg.messageTimestamp && msg.key?.remoteJid === targetGroupJid) {
            storeMessage(db, msg);
            newMessages++;
          }
        } catch (err) {
          console.error('Error storing message from history:', err);
        }
      }
      
      if (newMessages > 0) {
        console.log(`Added ${newMessages} messages from history sync`);
        messagesAdded += newMessages;
      }
      
      // If we successfully received messages, we can finish early
      if (newMessages > 0 && !isFinishing) {
        console.log('\nHistory sync successful! Finishing sync...');
        isFinishing = true;
      }
    }  
      console.log('Fetching group details...');
      try {
        // Fetch all groups
        const groups = await sock.groupFetchAllParticipating();
        console.log(`Found ${Object.keys(groups).length} groups`);
        
        // Find target group
        const group = Object.entries(groups).find(([jid, info]) => 
          info.subject === TARGET_GROUP_NAME
        );
        
        if (group) {
          const [jid, info] = group;
          targetGroupJid = jid;
          
          console.log(`Found target group: ${info.subject} (${targetGroupJid})`);
          console.log(`Participants: ${info.participants.length}`);
          
          // Store group info
          storeGroupInfo(
            db, 
            targetGroupJid, 
            info.subject, 
            info.desc || null,
            info.participants.length
          );
          
          // Calculate the timestamp from which to fetch messages
          const fromTimestamp = Math.floor((Date.now() - timePeriod) / 1000);
          console.log(`Fetching messages from ${new Date(fromTimestamp * 1000).toISOString()} onwards...`);
          
          try {
            console.log(`Looking for messages since ${new Date(fromTimestamp * 1000).toISOString()}...`);
            
            console.log('IMPORTANT: This script is completely passive and will NEVER send any messages to your group.');
            console.log('Retrieving historical messages from WhatsApp is limited by the WhatsApp Web API.');
            
            // Get the last message in the database to use as reference point
            const lastMessageQuery = db.prepare(`
              SELECT id, timestamp FROM messages 
              WHERE remoteJid = ? 
              ORDER BY timestamp DESC LIMIT 1
            `);
            const lastMessage = targetGroupJid ? lastMessageQuery.get(targetGroupJid) as any : null;
            
            // Setup message handlers before requesting any history
            // 1. Regular message handler
            sock.ev.on('messages.upsert', ({ messages, type }) => {
              if (type === 'append' || type === 'notify') {
                for (const msg of messages) {
                  // Check for history sync notification messages
                  if (msg.message?.protocolMessage?.type === proto.Message.ProtocolMessage.Type.HISTORY_SYNC_NOTIFICATION) {
                    console.log('Received history sync notification');
                    try {
                      const historySyncNotification = getHistoryMsg(msg.message);
                      if (historySyncNotification) {
                        // Process on-demand history sync
                        downloadAndProcessHistorySyncNotification(historySyncNotification, {})
                          .then(({ messages: historyMessages }) => {
                            console.log(`Processed ${historyMessages.length} history messages`);
                            // Process and store messages
                            for (const histMsg of historyMessages) {
                              if (histMsg.key?.remoteJid === targetGroupJid) {
                                const histTimestamp = histMsg.messageTimestamp as number;
                                // Calculate from timestamp
                                const localFromTimestamp = Math.floor((Date.now() - timePeriod) / 1000);
                                if (histTimestamp && histTimestamp >= localFromTimestamp) {
                                  try {
                                    storeMessage(db, histMsg);
                                    messagesAdded++;
                                    console.log(`Stored historical message from: ${new Date(histTimestamp * 1000).toISOString()}`);
                                  } catch (error) {
                                    console.error('Failed to store historical message:', error);
                                  }
                                }
                              }
                            }
                          })
                          .catch(err => console.error('Error processing history sync notification:', err));
                      }
                    } catch (error) {
                      console.error('Error handling history sync notification:', error);
                    }
                  } 
                  // Regular message processing
                  else if (msg.key && msg.key.remoteJid === targetGroupJid) {
                    const msgTimestamp = msg.messageTimestamp as number;
                    // Calculate from timestamp
                    const localFromTimestamp = Math.floor((Date.now() - timePeriod) / 1000);
                    if (msgTimestamp && msgTimestamp >= localFromTimestamp) {
                      try {
                        storeMessage(db, msg);
                        messagesAdded++;
                        console.log(`Stored message from: ${new Date(msgTimestamp * 1000).toISOString()}`);
                      } catch (error) {
                        console.error('Failed to store message:', error);
                      }
                    }
                  }
                }
              }
            });
            
            // 2. History sync handler - handles bulk history events
            sock.ev.on('messaging-history.set', ({ messages, chats, isLatest, syncType }) => {
              console.log(`Received ${messages.length} messages from history sync, type: ${syncType}`);
              
              for (const msg of messages) {
                // Only process messages from the target group
                if (msg.key && msg.key.remoteJid === targetGroupJid) {
                  const msgTimestamp = msg.messageTimestamp as number;
                  // Calculate from timestamp
                  const localFromTimestamp = Math.floor((Date.now() - timePeriod) / 1000);
                  if (msgTimestamp && msgTimestamp >= localFromTimestamp) {
                    try {
                      storeMessage(db, msg);
                      messagesAdded++;
                      console.log(`Stored historical message from: ${new Date(msgTimestamp * 1000).toISOString()}`);
                    } catch (error) {
                      console.error('Failed to store historical message:', error);
                    }
                  }
                }
              }
            });
            
            // If we have a reference message, attempt to request history
            if (lastMessage) {
              console.log(`Found reference message from ${new Date(lastMessage.timestamp * 1000).toISOString()}`);
              
              try {
                // Prepare message key as reference point
                const refKey = {
                  remoteJid: targetGroupJid,
                  id: lastMessage.id,
                  fromMe: lastMessage.fromMe === 1 ? true : false,
                  participant: lastMessage.participant
                };
                
                // Try a more aggressive approach to trigger iOS notifications
                console.log('Attempting to fetch message history...');
                console.log('\n====== IMPORTANT: CHECK YOUR PHONE NOW ======');
                console.log('Your device should show a WhatsApp notification');
                console.log('Make sure:');
                console.log('1. Your phone is unlocked and WhatsApp is open');
                console.log('2. You are viewing the target group chat');
                console.log('3. IMPORTANT: Minimize the app and then open it again');
                console.log('4. Scroll through recent messages in the chat');
                console.log('==========================================\n');
                
                try {
                  // First approach - mark messages as read which should trigger notifications
                  // This approach is used in the Baileys example.ts
                  console.log('Sending read receipt to trigger sync...');
                  await sock.readMessages([refKey]);
                  
                  if (sock.fetchMessageHistory) {
                    // Second approach - using fetchMessageHistory
                    const historyRequestId = await sock.fetchMessageHistory(
                      50, // number of messages to fetch (max 50-100 per WhatsApp limits)
                      refKey, // reference message key
                      lastMessage.timestamp // reference timestamp
                    );
                    
                    console.log(`History request initiated with ID: ${historyRequestId}`);
                    if (targetGroupJid) {
                      onDemandRequestMap.set(historyRequestId, targetGroupJid);
                    }
                  }
                    
                    // Wait 5 seconds to allow iOS to process notifications
                    console.log('Waiting 5 seconds for iOS notifications to appear...');
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
{{ ... }}
            
            console.log('Passively waiting for messages - NO messages will be sent to your group');
           
            // Wait for a longer period to allow sync to complete
            // How long to continue syncing (in milliseconds)
const syncTimeoutMs = 10000; // 10 seconds
            console.log('IMPORTANT: Keep your WhatsApp mobile app open during this time!');
            console.log('TIP: Opening the target group chat on your phone may help sync faster\n');
            
            // Set a flag to detect if we're making progress
            let initialMessageCount = messagesAdded;
{{ ... }}
            
            // Set a flag to detect if we're making progress
            let initialMessageCount = messagesAdded;
            let stuckCounter = 0;
            const maxStuckCount = 3; // If no progress for 30 seconds, try alternative method
                        // Wait in 10-second increments to give progress updates
              let elapsedTime = 0;
              for (let i = 0; i < 1; i++) { // Only run for 10 seconds
                console.log(`Sync progress: ${i+1}/1 (${(i+1)*10} seconds elapsed)`);
                
                // We're using a shorter timeout now
                await new Promise(resolve => setTimeout(resolve, 10000));
                elapsedTime += 10000;
                
                // Quick timeout since we want to finish in 10 seconds
                console.log(`\nSync timeout reached (10 seconds). Finishing sync...`);
                break;
              }
              // Check if we're making progress
              if (messagesAdded === initialMessageCount) {
                stuckCounter++;
                console.log(`No new messages for ${stuckCounter * 10} seconds...`);
                
{{ ... }}
                if (stuckCounter >= maxStuckCount && targetGroupJid) {
                  console.log('\n\x1b[33m=== NO NEW MESSAGES RECEIVED ===\x1b[0m');
                  console.log('Please make sure your phone has WhatsApp open');
                  console.log('Try minimizing and reopening the WhatsApp app');
                  
                  // Reset counter to avoid showing this message too often
                  stuckCounter = 0;
                  console.log('\x1b[33m===================================\x1b[0m\n');
                }
              } else {
                // We made progress, reset the counter
                stuckCounter = 0;
                initialMessageCount = messagesAdded;
              }
            }
            
            // After waiting, check the total messages we got
            const countStmt = db.prepare(`
              SELECT COUNT(*) as count FROM messages 
              WHERE remoteJid = ?
            `);
            const result = targetGroupJid ? countStmt.get(targetGroupJid) as {count: number} : {count: 0};
            const messageCount = result?.count || 0;
            
            console.log(`\nSync complete!`);
            console.log(`Total messages in database for "${TARGET_GROUP_NAME}": ${messageCount}`);
            console.log(`Messages added in this sync: ${messagesAdded}`);
            
            // If no messages were collected, provide detailed guidance
            if (messagesAdded === 0 && targetGroupJid) {
              console.log('\n\x1b[31mNo new messages found within the specified time period\x1b[0m');
              console.log('\nThis could be because:');
              console.log('1. There are no new messages in this time range');
              console.log('2. WhatsApp mobile app was not kept open during sync');
              console.log('3. WhatsApp server limitations on history retrieval');
              
              // Get last message timestamp
              if (targetGroupJid) {
                const lastTimestamp = getLastMessageTimestamp(db, targetGroupJid);
                if (lastTimestamp > 0) {
                  console.log(`\nLast message in database from: ${new Date(lastTimestamp * 1000).toISOString()}`);
                } else {
                  console.log('\nNo previous messages found in the database');
                }
              }
              
              console.log('\n\x1b[33mSUGGESTIONS TO IMPROVE RESULTS:\x1b[0m');
              console.log('\x1b[33m1. Make sure your phone is unlocked with WhatsApp open\x1b[0m');
              console.log('\x1b[33m2. Open the target group chat and scroll through recent messages\x1b[0m');
              console.log('\x1b[33m3. Try running this command again:\x1b[0m');
              console.log('\x1b[36m   pnpm run sync-messages -- 1d\x1b[0m');
              console.log('\x1b[33m4. If that doesn\'t work, try with a longer time period:\x1b[0m');
              console.log('\x1b[36m   pnpm run sync-messages -- 1w\x1b[0m');
              console.log('\x1b[33m5. For iOS users: make sure notifications are enabled for WhatsApp\x1b[0m');
              
              console.log('\n\x1b[33mIMPORTANT: WhatsApp has limitations on historical message access.\x1b[0m');
              console.log('\x1b[33mRunning this script regularly will help build a complete history over time.\x1b[0m');
            }
          } catch (error) {
            console.error('Error fetching message history:', error);
            console.log('Falling back to standard history sync...');
          }
        } else {
          console.log(`Target group "${TARGET_GROUP_NAME}" not found. Available groups:`);
          Object.entries(groups).forEach(([jid, groupInfo]) => {
            console.log(`- ${groupInfo.subject}`);
          });
          
          console.log('\n\x1b[31mERROR: Target group not found\x1b[0m');
          process.exit(1);
        }
      } catch (error) {
        console.error('Error fetching groups:', error);
        process.exit(1);
      }
    } else if (connection === 'close') {
      const statusCode = (lastDisconnect?.error as Boom)?.output?.statusCode;
      
      if (statusCode === DisconnectReason.loggedOut) {
        console.log('\n\x1b[31m==================================\x1b[0m');
        console.log('\x1b[31mERROR: Logged out from WhatsApp\x1b[0m');
        console.log('\x1b[31mPlease run the login script first:\x1b[0m');
        console.log('\x1b[36mpnpm run whatsapp-login\x1b[0m');
        console.log('\x1b[31m==================================\x1b[0m\n');
        process.exit(1);
      } else if (statusCode === 515) {
        console.log('\n\x1b[31m==================================\x1b[0m');
        console.log('\x1b[31mERROR: Connection closed with status: 515\x1b[0m');
        console.log('\x1b[31mYour session may have expired.\x1b[0m');
        console.log('\x1b[31mPlease run the login script again:\x1b[0m');
        console.log('\x1b[36mpnpm run whatsapp-login\x1b[0m');
        console.log('\x1b[31m==================================\x1b[0m\n');
        process.exit(1);
      } else {
        console.log(`Connection closed with status: ${statusCode}`);
        process.exit(1);
      }
    }
  });
}

// Start the script
syncGroupMessages().catch(err => {
  console.error('Unhandled error:', err);
  process.exit(1);
});
